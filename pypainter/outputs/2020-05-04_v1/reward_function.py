
import math

def clamp(n, l, r):
    l, r = (l, r) if l < r else (r, l)
    return min(max(n, l), r)

def vMul(a, h):
    return [a[0]*h, a[1]*h]

def vSub(a, b):
    return [a[0]-b[0],a[1]-b[1]]

def vDot(a, b):
    return a[0]*b[0]+a[1]*b[1]

def vLength(a):
    return math.sqrt(sum([e**2 for e in a]))

def opUnion(n):
    """
    n: a list of signed distances
    """
    return min(n)

def sdLine(p, a, b):
    """
    p: point [x, y]
    a: start of line [x, y]
    b: end of line [x, y]
    """
    pa, ba = vSub(p, a), vSub(b, a)
    h = clamp(vDot(pa, ba)/vDot(ba, ba), 0.0, 1.0)

    return vLength(vSub(pa, vMul(ba, h)))

TRACK_LINES = [
    [[-7.661883, 1.249479], [-6.950770, 0.304714]],
    [[-6.950770, 0.304714], [-6.361562, -0.579098]],
    [[-6.361562, -0.579098], [-5.873941, -1.330847]],
    [[-5.873941, -1.330847], [-5.467590, -1.808309]],
    [[-5.467590, -1.808309], [-4.604095, -2.143548]],
    [[-4.604095, -2.143548], [-0.428843, -2.143548]],
    [[-0.428843, -2.143548], [3.990220, -2.194342]],
    [[3.990220, -2.194342], [7.322295, -2.163866]],
    [[7.322295, -2.163866], [8.195949, -1.808309]],
    [[8.195949, -1.808309], [8.632775, -1.147989]],
    [[8.632775, -1.147989], [8.917221, -0.091478]],
    [[8.917221, -0.091478], [8.815634, 0.893923]],
    [[8.815634, 0.893923], [8.551506, 2.092657]],
    [[8.551506, 2.092657], [8.307695, 3.210121]],
    [[8.307695, 3.210121], [7.931821, 3.880599]],
    [[7.931821, 3.880599], [7.464518, 4.205680]],
    [[7.464518, 4.205680], [6.692451, 4.429173]],
    [[6.692451, 4.429173], [6.093084, 4.378379]],
    [[6.093084, 4.378379], [5.514035, 4.032981]],
    [[5.514035, 4.032981], [5.351495, 3.423455]],
    [[5.351495, 3.423455], [5.463241, 2.824088]],
    [[5.463241, 2.824088], [5.788321, 2.062181]],
    [[5.788321, 2.062181], [6.021973, 1.381543]],
    [[6.021973, 1.381543], [6.062608, 0.934558]],
    [[4.325459, 0.650112], [3.858156, 1.086939]],
    [[3.858156, 1.086939], [3.360377, 1.676147]],
    [[3.360377, 1.676147], [2.893074, 2.285674]],
    [[2.893074, 2.285674], [2.415612, 2.956152]],
    [[2.415612, 2.956152], [1.806086, 3.494566]],
    [[1.806086, 3.494566], [1.044178, 3.646948]],
    [[1.044178, 3.646948], [0.383858, 3.392979]],
    [[0.383858, 3.392979], [-0.205350, 2.885041]],
    [[-0.205350, 2.885041], [-0.560907, 2.163768]],
    [[-0.560907, 2.163768], [-0.936781, 0.802494]],
    [[-0.936781, 0.802494], [-1.414243, 0.253920]],
    [[-1.414243, 0.253920], [-2.267579, -0.121954]],
    [[-2.267579, -0.121954], [-3.354567, -0.162589]],
    [[-3.354567, -0.162589], [-4.289174, 0.264079]],
    [[-4.014887, 2.590436], [-2.938058, 2.732659]],
    [[-2.938058, 2.732659], [-2.470755, 3.037422]],
    [[-2.877105, 4.733936], [-4.146951, 4.815206]],
    [[-4.146951, 4.815206], [-5.477749, 4.551078]],
    [[-2.470755, 3.037422], [-2.186309, 3.484408]],
    [[-2.186309, 3.484408], [-2.196468, 4.032981]],
    [[-2.196468, 4.032981], [-2.450437, 4.449491]],
    [[-2.450437, 4.449491], [-2.877105, 4.733936]],
    [[-5.061240, 1.818370], [-4.868223, 2.173927]],
    [[-4.868223, 2.173927], [-4.492349, 2.407578]],
    [[-4.492349, 2.407578], [-4.014887, 2.590436]],
    [[-5.477749, 4.551078], [-6.788230, 4.185362]],
    [[-6.788230, 4.185362], [-7.682201, 3.799329]],
    [[-7.682201, 3.799329], [-8.119028, 3.088216]],
    [[-8.119028, 3.088216], [-8.149505, 2.346626]],
    [[-8.149505, 2.346626], [-8.017440, 1.757418]],
    [[-8.017440, 1.757418], [-7.661883, 1.249479]],
    [[-4.289174, 0.264079], [-4.756477, 0.731382]],
    [[-4.756477, 0.731382], [-5.091716, 1.310432]],
    [[-5.091716, 1.310432], [-5.061240, 1.818370]],
    [[6.062608, 0.934558], [5.818798, 0.609477]],
    [[5.818798, 0.609477], [5.412447, 0.385984]],
    [[5.412447, 0.385984], [4.874032, 0.385984]],
    [[4.874032, 0.385984], [4.325459, 0.650112]],
]

def sdTrack(p):
    d = [sdLine(p, line[0], line[1]) for line in TRACK_LINES]

    return opUnion(d)



EXP_STEPS = 120
MAX_STEPS = 200
BANDWIDTH = 0.5

def m_pow(x, power=1.8, shift_y=-1.0):
    return -math.pow(x, power) - shift_y

def m_pow16_7(x):
    return m_pow(x, power=2.285714)

def m_pow4_5(x):
    return m_pow(x, power=1.5)

def hyperbola(x, scale=0.1, shift_x=-0.2):
    return scale/(x-shift_x)

def hyper_decay(x):
    return hyperbola(x, scale=0.1, shift_x=-4.3)

def max_blend(x, y, k=8.0, k1_coef=1.0, k2_coef=2.0, fitness=2.0):
    """
    k: smoothness
    k1_coef: x portion
    k2_coef: y portion
    fitness: log base
    """

    return math.log( math.pow(fitness, k*k1_coef*x)+math.pow(fitness, k*k2_coef*y) ,fitness)/k

def f(x):
    return max_blend(m_pow4_5(abs(x)), hyper_decay(x))

def reward_function(params):
    progress = params['progress']
    steps = params['steps']
    distance_from_center = params['distance_from_center']
    track_width = params['track_width']

    p = [params['x'], params['y']]

    def smooth_penalty():
        c = float((MAX_STEPS-EXP_STEPS))
        x = float(progress)/max(float(steps), 1.0)
        return max( -c/(c+float(float(MAX_STEPS)/200.0*EXP_STEPS*x)-float(MAX_STEPS/2.0)+2.0), 0.0)

    def linear_penalty():
        return max(float(progress*(float(EXP_STEPS)/100.0))/max(steps, 1.0), 0.0)

    def one():
        return 1.0

    def penalty():
        return one()

    def rew(x):
        return f(x)*penalty()

    # if car is on the track
    dist = sdTrack(p)/(track_width*BANDWIDTH) if distance_from_center < track_width*0.5 else 1.0

    # clamp track region
    norm_dist = min(dist, 1.0)

    reward = max(f(norm_dist)*penalty(), 0.0)

    return reward
