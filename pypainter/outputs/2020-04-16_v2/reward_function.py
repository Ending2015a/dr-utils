
import math

def clamp(n, l, r):
    l, r = (l, r) if l < r else (r, l)
    return min(max(n, l), r)

def vMul(a, h):
    return [a[0]*h, a[1]*h]

def vSub(a, b):
    return [a[0]-b[0],a[1]-b[1]]

def vDot(a, b):
    return a[0]*b[0]+a[1]*b[1]

def vLength(a):
    return math.sqrt(sum([e**2 for e in a]))

def opUnion(n):
    """
    n: a list of signed distances
    """
    return min(n)

def sdLine(p, a, b):
    """
    p: point [x, y]
    a: start of line [x, y]
    b: end of line [x, y]
    """
    pa, ba = vSub(p, a), vSub(b, a)
    h = clamp(vDot(pa, ba)/vDot(ba, ba), 0.0, 1.0)

    return vLength(vSub(pa, vMul(ba, h)))

TRACK_LINES = [
    [[-6.951657, 2.045311], [-6.755911, 2.887871]],
    [[-6.866550, 1.092112], [-6.951657, 2.045311]],
    [[-6.866550, 1.092112], [-6.296333, 0.232531]],
    [[-5.760159, -0.116408], [-6.296333, 0.232531]],
    [[-5.760159, -0.116408], [-5.045259, -0.465347]],
    [[-5.045259, -0.465347], [-4.168657, -0.712157]],
    [[-4.168657, -0.712157], [-3.292054, -0.754710]],
    [[-2.517580, -0.729178], [-3.292054, -0.754710]],
    [[-2.517580, -0.729178], [-1.879277, -0.729178]],
    [[-1.087782, -0.899393], [-1.879277, -0.729178]],
    [[-1.087782, -0.899393], [0.018610, -1.401524]],
    [[0.018610, -1.401524], [0.937766, -1.673867]],
    [[6.605895, -0.882371], [6.869726, -0.175983]],
    [[6.605895, -0.882371], [6.010145, -1.461099]],
    [[6.801641, 0.530406], [6.869726, -0.175983]],
    [[6.801641, 0.530406], [6.520787, 1.126155]],
    [[6.520787, 1.126155], [5.984613, 1.551690]],
    [[2.052668, 2.445314], [4.180344, 2.028290]],
    [[-2.075024, 6.470877], [-1.462253, 6.155981]],
    [[-2.721837, 6.487899], [-2.075024, 6.470877]],
    [[-2.721837, 6.487899], [-3.411204, 6.351727]],
    [[-1.462253, 6.155981], [-1.011186, 5.747468]],
    [[-4.194189, 6.028321], [-3.411204, 6.351727]],
    [[-4.194189, 6.028321], [-4.892067, 5.364486]],
    [[-5.334623, 4.853844], [-4.892067, 5.364486]],
    [[-5.334623, 4.853844], [-5.726116, 4.394266]],
    [[-6.347397, 3.577238], [-5.726116, 4.394266]],
    [[-6.347397, 3.577238], [-6.755911, 2.887871]],
    [[0.937766, -1.673867], [1.729261, -1.793016]],
    [[3.397359, -1.852592], [1.729261, -1.793016]],
    [[5.303757, 1.738926], [5.984613, 1.551690]],
    [[5.303757, 1.738926], [4.180344, 2.028290]],
    [[-0.687779, 5.194272], [-1.011186, 5.747468]],
    [[-0.687779, 5.194272], [-0.398415, 4.470862]],
    [[-0.398415, 4.470862], [-0.100540, 3.815537]],
    [[-0.100540, 3.815537], [0.478188, 3.330427]],
    [[0.478188, 3.330427], [1.278194, 2.768721]],
    [[1.278194, 2.768721], [2.052668, 2.445314]],
    [[3.397359, -1.852592], [4.571836, -1.818549]],
    [[4.571836, -1.818549], [5.397375, -1.673867]],
    [[5.397375, -1.673867], [6.010145, -1.461099]],
]

def sdTrack(p):
    d = [sdLine(p, line[0], line[1]) for line in TRACK_LINES]

    return opUnion(d)



STEPS_PROGRESS_RATE = 1.5

def reward_function(params):
    progress = params['progress']
    steps = params['steps']
    distance_from_center = params['distance_from_center']
    track_width = params['track_width']

    p = [params['x'], params['y']]

    def pow16_7(x):
        return -math.pow(abs(x), 2.285714) + 1

    def penalty():
        return float(progress*STEPS_PROGRESS_RATE)/max(float(steps), 1.0)

    def f(x):
        return pow16_7(x)

    norm_dist = distance_from_center/(track_width*0.5)

    # if car is on the track
    dist = sdTrack(p) if distance_from_center < track_width*0.5 else distance_from_center

    # clamp track region
    norm_dist = min(dist/(track_width*0.5), 1.0)

    reward = clamp(f(norm_dist)*penalty(), 0.0, 1.0)

    return reward
